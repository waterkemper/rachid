import type * as types from './types.ts';
interface WorkerOptions<T> {
    id: string;
    name: string;
    options: types.WorkOptions;
    interval: number;
    fetch: () => Promise<types.Job<T>[]>;
    onFetch: (jobs: types.Job<T>[]) => Promise<void>;
    onError: (err: any) => void;
}
declare class Worker<T = unknown> {
    readonly id: string;
    readonly name: string;
    readonly options: types.WorkOptions;
    readonly fetch: () => Promise<types.Job<T>[]>;
    readonly onFetch: (jobs: types.Job<T>[]) => Promise<void>;
    readonly onError: (err: any) => void;
    readonly interval: number;
    jobs: types.Job<T>[];
    createdOn: number;
    state: types.WorkerState;
    lastFetchedOn: number | null;
    lastJobStartedOn: number | null;
    lastJobEndedOn: number | null;
    lastJobDuration: number | null;
    lastError: any;
    lastErrorOn: number | null;
    stopping: boolean;
    stopped: boolean;
    private loopDelayPromise;
    private beenNotified;
    private runPromise;
    constructor({ id, name, options, interval, fetch, onFetch, onError }: WorkerOptions<T>);
    start(): void;
    private run;
    notify(): void;
    stop(): Promise<void>;
    toWipData(): types.WipData;
}
export default Worker;
//# sourceMappingURL=worker.d.ts.map